(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{94:function(e,a,t){"use strict";t.r(a);var c=t(0),i=t.n(c),n=(t(105),t(109)),l=(t(107),t(22));t(108),t(62);a.default=function(){var e=Object(l.default)().siteConfig,a=void 0===e?{}:e;return i.a.createElement(n.a,{title:"Hello from "+a.title,description:"Pluggable caching engine to build and scale high performance cache services"},i.a.createElement("main",null,i.a.createElement("section",null,i.a.createElement("div",{className:"container"},i.a.createElement("div",{className:"row"},i.a.createElement("div",{class:"col col--6"},i.a.createElement("p",null,"CacheLib is a general purpose caching engine that facilitates the easy development, scaling and maintenance of high performing caches. CacheLib was designed by drawing on experiences across a range of caching use cases at Facebook.  From its first deployment in 2017, CacheLib now powers over 70 services at Facebook including",i.a.createElement("b",null,"Facebook\u2019s CDN, social-graph cache, application look-aside cache, and block-storage system"),"."),i.a.createElement("p",null,"Large scale web service providers rely on caching to deliver a great user experience. While web applications commonly leverage remote look-aside caches, several other applications need a local in-process cache because, either they can not tolerate the RPC overhead of a common remote cache, or require strict cache consistency, or need domain specific cache features. These application teams often build and maintain application specific, highly specialized, local in-process caches. Without the ability to share improvements among each other, this approach leads to each team solving the hard problems of scaling cache performance in isolation."),i.a.createElement("p",null,"CacheLib is a thread-safe, scalable, C++ library that provides the core caching functionality. It enables services",i.a.createElement("b",null,"\xa0to customize and scale highly concurrent caches easily, and to leverage the improvements across different caching systems by using a simple, expressive, thread-safe API."))),i.a.createElement("div",{class:"col col--6"},i.a.createElement("h4",null,"Features"),i.a.createElement("ul",null,i.a.createElement("li",null,"Efficient implementations of caching indexes, eviction policies"),i.a.createElement("li",null,"Support for seamless hybrid caching (caches composed of DRAM and Flash) to achieve high hit ratios while caching large working sets. Relevant for content delivery cache use cases."),i.a.createElement("li",null,"Optimizations for high throughput, low memory, and low CPU usage for a broad range of workloads."),i.a.createElement("li",null,"Native implementations of arrays and hashmaps that can be cached and mutated efficiently without incurring any serialization overhead."),i.a.createElement("li",null,"Ability to perform warm restarts that retain the state of the cache")))),i.a.createElement("div",{className:"row"},i.a.createElement("div",{class:"col col--12"},i.a.createElement("h2",null,"OSDI\u201920"),i.a.createElement("p",null,i.a.createElement("a",{href:"https://www.usenix.org/conference/osdi20/presentation/berg"},i.a.createElement("em",null,"CacheLib"),"Caching Engine: Design and Experiences at Scale"),"was published at the USENIX OSDI 20 Conference. The publication can be accessed",i.a.createElement("a",{href:"https://www.usenix.org/system/files/osdi20-berg.pdf"},"here"),"and the video of the presentation is below."),i.a.createElement("iframe",{width:"905",height:"509",src:"https://www.youtube.com/embed/wp_X-Zg9WEo",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})))))))}}}]);