"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2504],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},c=Object.keys(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,c=e.originalType,s=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),d=l(n),p=a,f=d["".concat(s,".").concat(p)]||d[p]||u[p]||c;return n?r.createElement(f,i(i({ref:t},h),{},{components:n})):r.createElement(f,i({ref:t},h))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var c=n.length,i=new Array(c);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var l=2;l<c;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7873:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return h},default:function(){return d}});var r=n(7462),a=n(3366),c=(n(7294),n(3905)),i=["components"],o={id:"Cachebench_Overview",title:"Overview"},s=void 0,l={unversionedId:"Cache_Library_User_Guides/Cachebench_Overview",id:"Cache_Library_User_Guides/Cachebench_Overview",isDocsHomePage:!1,title:"Overview",description:"CacheBench is a benchmark suite that can read a workload configuration file, simulate cache behavior as stipulated in the config, and produce performance summary for the simulated cache. Results include metrics such as hit rate, evictions, write rate to flash cache, latency, etc. The workload configs can be hand-written by a human, produced by a workload analyzer, or backed by raw production cachelib traces. The main customization points into CacheBench are through writing workload configs or custom workload generators.",source:"@site/docs/Cache_Library_User_Guides/Cachebench_Overview.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/Cachebench_Overview",permalink:"/docs/Cache_Library_User_Guides/Cachebench_Overview",editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/Cachebench_Overview.md",version:"current",frontMatter:{id:"Cachebench_Overview",title:"Overview"},sidebar:"someSidebar",previous:{title:"Structured Cache",permalink:"/docs/Cache_Library_User_Guides/Structured_Cache"},next:{title:"Developing for Cachebench",permalink:"/docs/Cache_Library_User_Guides/Developing_for_Cachebench"}},h=[{value:"Build the latest cachebench",id:"build-the-latest-cachebench",children:[]},{value:"Running cachebench for Facebook hardware validation",id:"running-cachebench-for-facebook-hardware-validation",children:[]},{value:"Analyzing the performance metrics",id:"analyzing-the-performance-metrics",children:[]},{value:"Plotting latency stats",id:"plotting-latency-stats",children:[]}],u={toc:h};function d(e){var t=e.components,o=(0,a.Z)(e,i);return(0,c.kt)("wrapper",(0,r.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"CacheBench is a benchmark suite that can read a workload configuration file, simulate cache behavior as stipulated in the config, and produce performance summary for the simulated cache. Results include metrics such as hit rate, evictions, write rate to flash cache, latency, etc. The workload configs can be hand-written by a human, produced by a workload analyzer, or backed by raw production cachelib traces. The main customization points into CacheBench are through writing workload configs or custom workload generators."),(0,c.kt)("p",null,(0,c.kt)("img",{src:n(8567).Z})),(0,c.kt)("h3",{id:"build-the-latest-cachebench"},"Build the latest cachebench"),(0,c.kt)("p",null,"Follow instructions in ",(0,c.kt)("a",{parentName:"p",href:"../installation/installation"},"Installation")," to build\ncachebench. This should install cachebench in your local machine under\n",(0,c.kt)("inlineCode",{parentName:"p"},"opt/cachelib/bin/cachebench")),(0,c.kt)("h3",{id:"running-cachebench-for-facebook-hardware-validation"},"Running cachebench for Facebook hardware validation"),(0,c.kt)("p",null,"Cachebench has three configs packaged for SSD validation. These are under ",(0,c.kt)("inlineCode",{parentName:"p"},"test_configs/ssd_perf/<service-domain>"),'. Currently, we have "tao-leader", "memcache-reg", and "memcache-wc" which represent three distinct cache workloads from Facebook.'),(0,c.kt)("p",null,"To run any of them, first ensure that the machine has sufficient free memory (50+GB). Next, modify the config.json file appropriately to reflect the SSD device setu;p. See ",(0,c.kt)("a",{parentName:"p",href:"Configuring_cachebench_parameters#storage-filedevicedirectory-path-info"},"configuring storage path")," for details. Then invoke the following."),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-shell"},"./cachebench --json_test_config test_configs/ssd_perf/<service-domain>/config.json --progress_stats_file=/tmp/cachebench.log\n")),(0,c.kt)("p",null,"This will stream the benchmark progress to the terminal and also log detailed stats to the specified file. The log file would contain a periodic dump of the latency  and cache stats, which  can then be plotted using some of the scripts.  If the stats are not intended to be collected, then skip the option ",(0,c.kt)("inlineCode",{parentName:"p"},"--progress_stats_file"),"."),(0,c.kt)("h3",{id:"analyzing-the-performance-metrics"},"Analyzing the performance metrics"),(0,c.kt)("p",null,"While cachebench runs, it will report some stats through the fb303 port. In addition, one can monitor the flash metrics from ODS on IOPS, nand writes etc. cachebench also periodically dumps some stats to the stdout, that can be processed later on."),(0,c.kt)("h3",{id:"plotting-latency-stats"},"Plotting latency stats"),(0,c.kt)("p",null,"The stats output can be parsed to plot NVM latency information over time. To do this, first ensure ",(0,c.kt)("inlineCode",{parentName:"p"},"gnuplot")," is installed:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-shell"},"yum install gnuplot\n")),(0,c.kt)("p",null,"Then run this command to get the latency stats:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-shell"},"./vizualize/extract_latency.sh /tmp/tao_leader.log\n")),(0,c.kt)("p",null,"This should produce a tsv file for read latency, a tsv file for write latency, and the corresponding ",(0,c.kt)("inlineCode",{parentName:"p"},"png")," files that have the graphs plotted."))}d.isMDXComponent=!0},8567:function(e,t,n){t.Z=n.p+"assets/images/cachebench-25d1d476ed27af8ec3a0b5033571dd1a.png"}}]);